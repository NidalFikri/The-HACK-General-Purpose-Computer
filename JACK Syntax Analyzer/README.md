# Project 10

How can we tell that a compiler is capable of ‘‘understanding’’ the language’s
syntax? Well, as long as the code generated by the compiler is doing what it is supposed
to do, we can optimistically assume that the compiler is operating properly.
Yet in this project I build only the syntax analyzer module of the compiler, with
no code generation capabilities. If we wish to unit-test the syntax analyzer in isolation,
we have to contrive some passive way to demonstrate that it ‘‘understands’’ the
source program. Our solution is to have the syntax analyzer output an XML file
whose format reflects the syntactic structure of the input program. By inspecting the
generated XML output, we should be able to ascertain that the analyzer is parsing
input programs correctly.

Here is the full picture for the two-tier compiler:
![syntax01](https://user-images.githubusercontent.com/33065305/94927566-c0381700-04c2-11eb-8a66-2839e136664b.png)

## Tokenizing:
To understand what is the process of tokenizing, consider the C code below:
![syntax02](https://user-images.githubusercontent.com/33065305/94927700-ec539800-04c2-11eb-9c33-4a4c16ec0799.png)

## Parsing Grammar:
Almost all programming languages, as well as most other formal languages used
for describing the syntax of complex file types, can be specified using formalisms
known as context-free grammars. A context-free grammar is a set of rules specifying
how syntactic elements in some language can be formed from simpler ones. For example,
the Java grammar allows us to combine the atoms 100,count, and <= into
the expression count<=100. In a similar fashion, the Java grammar allows us to
ascertain that the text count<=100 is a valid Java expression. Indeed, each grammar
has a dual perspective. From a declarative standpoint, the grammar specifies allowable
ways to combine tokens, also called terminals, into higher-level syntactic
elements, also called non-terminals. From an analytic standpoint, the grammar is a
prescription for doing the reverse: parsing a given input (set of tokens resulting from
the tokenizing phase) into non-terminals, lower-level non-terminals, and eventually
terminals that cannot be decomposed any further.

To understand what is meant by the language syntax or grammar, consider the figure below: 
![syntax03](https://user-images.githubusercontent.com/33065305/94927961-45233080-04c3-11eb-8525-c6868af84ab1.png)


## JACK Language Grammar:
![syntax04](https://user-images.githubusercontent.com/33065305/94928202-9d5a3280-04c3-11eb-9ce6-7f7de2989b5f.png)

![syntax05](https://user-images.githubusercontent.com/33065305/94928208-a1865000-04c3-11eb-887c-a842a9c33236.png)

## Syntax Analyzer Output:
![syntax06](https://user-images.githubusercontent.com/33065305/94928296-c4b0ff80-04c3-11eb-8ebe-de8434b4881d.png)


